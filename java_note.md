# **JAVA NOTE**
**静态方法为什么不能调用非静态成员?**
这个需要结合 JVM 的相关知识，**主要原因如下**：

1.静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2.在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

**Java和C++的区别**
1.Java 不提供指针来直接访问**内存**，程序内存更加安全
2.Java 的类是**单继承**的，C++ 支持**多重继承**；虽然 Java 的类不可以多继承，但是接口可以多继承。
3.Java **有自动内存管理垃圾回收机制(GC)**，不需要程序员手动释放无用内存。
4.C ++同时支持**方法重载和操作符重载**，但是 Java 只支持**方法重载**（操作符重载增加了**复杂性**，这与 Java 最初的设计思想不符）。

**== 和 equals() 的区别**
== 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，== 比较的是值。
- 对于引用数据类型来说，== 比较的是对象的内存地址。
>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

equals() 不能用于判断基本数据类型的变量，只能用来判断两个**对象**是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。

>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

**装箱和拆箱**
- 装箱是为了支持泛型和提供更多丰富功能，并将基础类型转化为对象，从而实现面向对象的思想。
- 基础类型只是数据，不是对象。
  
**创建一个对象用什么运算符?对象实体与对象引用有何不同?**
- new 运算符，new 创建对象实例（对象实例在**堆内存**中），对象引用指向对象实例（对象引用存放在**栈内存**中）。